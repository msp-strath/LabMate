\documentclass{ws-procs9x6}

%%%% Packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage[colorlinks=true]{hyperref}
\usepackage{microtype}
\usepackage{proof}
\usepackage{mathtools}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%% Macros %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\pct}{\texttt{\symbol{37}}}
\newcommand{\dir}{\texttt{\symbol{62}}}
\newcommand{\res}{\texttt{\symbol{60}}}
\newcommand{\lcb}{\texttt{\symbol{123}}}
\newcommand{\rcb}{\texttt{\symbol{125}}}
\newcommand{\lsb}{\texttt{\symbol{91}}}
\newcommand{\rsb}{\texttt{\symbol{93}}}

\newcommand{\istype}[1]{#1\ \textsf{type}}
\newcommand{\isadd}[1]{#1\ \textsf{numeric}}
\newcommand{\ismult}[3]{(#1, #2, #3)\ \textsf{multipliable}}

\newcommand{\append}{+\!\!\!+}
\newcommand{\hjux}[2]{{#1}|{#2}}
\newcommand{\vjux}[2]{\frac{#1}{#2}}

\newcommand{\One}{\mathbf{1}}
\newcommand{\Matrix}[5]{\mathsf{Matrix}\,#1\,#2\,#3\,#4\,#5}
\newcommand{\List}[1]{\mathsf{List}\,#1}



\newcommand{\remph}{\emph}

\newcommand{\todo}[1]{\textcolor{red}{\textbf{TODO: #1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title{LabMate: supporting types for MATLAB}
\author{Neil Ghani, Conor McBride, Georgi Nakov, Fredrik Nordvall Forsberg, Alasdair Forbes, Keith Lines, Ian Smith}
\address{University of Strathclyde, National Physical Laboratory}
%TODO: Affiliations

\bodymatter

\section{Introduction}

MATLAB is a key workhorse in many scientific and engineering
disciplines that are heavily reliant on numerical methods. It helps us
do powerful things. However, as with all software, MATLAB code may
contain implementation errors and bugs. In good programming practice
for MATLAB developers, programmers use comments to make clear what
physical systems their data concern and how the data should be
interpreted, specifying, e.g., units of measure for
quantities. Regrettably, none of this rich and often disciplined
metadata is perceptible to MATLAB, which instead enforces the
compatibility of producers and consumers of data by run-time checking
of tags which indicate only machine representation, not any form of
meaning. In reality, the programmers document meaning for each other's
benefit but keep the machine in the dark.

To rectify this situation, we have developed LabMate, which is a tool
to reify current virtuous engineering practices as a formal language
of MATLAB comments. MATLAB remains in the dark, but LabMate reads,
assesses, and transforms MATLAB programs in accordance with these
comments.
%
Behind the scenes, LabMate is retrofitting an expressive type system
to MATLAB, with the more of the meaning of programs recorded in their
types.
%
This gives a lightweight and low-cost way for MATLAB programmers to
express their intent, and in a language they are already working in,
rather than starting over from scratch.
%
While type systems and their theory is a well established discipline
of computer science, the development of LabMate has a several novel
advances on the algebraic structure required to classify
matrices and the meanings of the quantities therein, e.g., their
physical dimensions. LabMate brings advanced type systems to
effectiveness within, rather than instead of, existing scientific and
engineering toolchains and practices.

\section{LabMate in action}
\label{sec:example}

% simple matrix multiplication example

Consider the problem of resistance calibration: \todo{explain here}.

% $t_i$ time ($\mathsf{T}$; in seconds); $v_i$ voltage ($\mathsf{ML}^2\mathsf{T}^{-3}\mathsf{I}^{-1}$; in volt)

\[
\begin{pmatrix*}
  t_1 & 1 & -1 & 0 & 0 \\
  t_2 & 1 & -1 & 0 & 0 \\
  t_3 & 1 & -1 & 0 & 0 \\
  t_4 & 1 & -1 & 0 & 0 \\
  t_5 & 1 & -1 & 0 & 0 \\
  t_6 & 0 & 0 & 1 & -1 \\
  t_7 & 0 & 0 & 1 & -1 \\
  t_8 & 0 & 0 & 1 & -1 \\
  t_9 & 0 & 0 & 1 & -1 \\
\end{pmatrix*}
\times
\begin{pmatrix}
  m \\
  c \\
  a \\
  c_{\text{offset}} \\
  a_{\text{offset}}
\end{pmatrix}
=
\begin{pmatrix}
  v_1 \\
  v_2 \\
  v_3 \\
  v_4 \\
  v_5 \\
  v_6 \\
  v_7 \\
  v_8 \\
  v_9
\end{pmatrix}
\]

This can be converted into a MATLAB problem with LabMate annotations as follows:
\begin{verbatim}
%> A :: [ 9 x 5 ] double
A = [ t1 1 -1 0 0
      t2 1 -1 0 0
      t3 1 -1 0 0
      t4 1 -1 0 0
      t5 1 -1 0 0
      t6 0 0 1 -1
      t7 0 0 1 -1
      t8 0 0 1 -1
      t9 0 0 1 -1 ]

%> B :: [ 5 x 1 ] double
B = [ m c a cOffset aOffset ]

C = A * B

%> typeof C
\end{verbatim}
%
\todo{Is computing C from A and B what we want?}
The lines starting with `\texttt{\%>}' are interpreted as ordinary comments by MATLAB, but as \remph{input directives} by LabMate. LabMate acts by reading the source code and outputting it again, but possibly with some additional \remph{responses} to the directives added.

Did you notice the error in the above code? The matrix \texttt{B} should be of size $5 \times 1$, but is erroneously of size $1 \times 5$ instead. LabMate detects this error and produces the following as output, where we have suppressed the same definition of \texttt{A} as above:
\begin{verbatim}
%> A :: [ 9 x 5 ] double
A = ...

%> B :: [ 5 x 1 ] double
B = [ m c a cOffset aOffset ]

C = A * B

%> typeof C
%< the type of C is quite a puzzle; unsolved constraints 5 =? 1, 1 =? 5
\end{verbatim}
%
That is, LabMate says that for \texttt{C} to have a sensible type, we need the (impossible) constraints $5 = 1$ and $1 = 5$ to be true, arising from the fact that we have declared \texttt{B} to be a $5 \times 1$ matrix, but in fact it is a $1 \times 5$ matrix. Note that the original source code has been retained, but a response has been inserted to our \texttt{typeof} query. If we change \texttt{B} to
\begin{verbatim}
B = [ m; c; a; cOffset; aOffset ]
\end{verbatim}
instead, then LabMate responds
\begin{verbatim}
%< C :: [ 9 x 1 ] double
\end{verbatim}
This way, LabMate can detect matrix size errors at development time, rather than at runtime.

\section{Types for matrices}

Under the hood, LabMate translates MATLAB expressions to typed
expressions in its own core type theory.
%
Since matrices feature heavily in MATLAB code, the type of matrices
plays a central role in this type theory.
%
We make this type rather precise, by allowing the type of each entry
in the matrix to vary according to the row and column of the entry:
%
we parameterise the type of matrices by a type $R$ associated with
each row, a type $C$ associated with each column, and a type $E(x,y)$
which might vary depending on the values of parameters $x : R$ and
$y : C$, as well as two lists $rs : \List{R}$ and $\List{C}$ --- the
idea being that the $i$th entry in the list $rs$ and the $j$th entry
in the list $cs$ determines the type of the $(i, j)$ coordinate in the
matrix.
%
Summarised as an inference rule, matrix types are thus formed as follows:
%
\[
  \infer{\istype{\Matrix{R}{C}{E}{rs}{cs}}}
  {
    \istype{R}
    &\quad
    \istype{C}
    &\quad
    x : R, y : C \vdash \istype{E(x,y)}
    &\quad
    rs : \List{R}
    &\quad
    cs : \List{C}
  }
\]

A notable special case is when both $R$ and $C$ are the unit type
$R = C = \One$, that is, the type with exactly one element.
%
In this case, there is only one type of entries $E$ (because both $x$
and $y$ must be the unique element of the unit type), and the only
information available in the lists $rs : \List{\One}$ and
$cs : \List{\One}$ is their length.
%
Thus, we have recovered $\Matrix{\One}{\One}{E}{m}{n}$ as the type of
$m \times n$ matrices with entries of type $E$, where $n$ and $m$ are
the unique lists over the unit type of length $n$ and $m$
respectively.

Another noteworthy special case which we want to support takes $R$ and
$R$ to be types of physical dimensions, with $E(d_1, d_2)$ to be the
type of physical quantities of dimension $d_1 \cdot d_2^{-1}$.
%
This way, we can reduce dimensional consistency checking \`a la
Kennedy~\cite{kennedyUOM} also for programs involving matrices,
following the work of Hart~\cite{hart}.
%
We will see in \sref{sec:example-revisited} how this can be helpful.

Terms of matrix type in the core type theory are built up from
$1 \times 1$ matrices and pasting matrices horizontally and vertically.
%
Singleton matrices have the following typing rule
\[
  \infer{[e] : \Matrix{R}{C}{E}{[r]}{[c]}}
    {r : R
      &\quad
      c : C
      &\quad
      e : E(r, c)
    }
\]
%
while horizontal and vertical pasting horizontally have the following
typing rules:
\[
  \infer{\hjux{A}{B} : \Matrix{R}{C}{E}{rs}{(cs_A \append cs_B)}}
  {
    A : \Matrix{R}{C}{E}{rs}{cs_A}
    &\quad
    B : \Matrix{R}{C}{E}{rs}{cs_B}
  }
\]
\[
  \infer{\vjux{A}{B} : \Matrix{R}{C}{E}{(rs_A \append rs_B)}{cs}}
  {
    A : \Matrix{R}{C}{E}{rs_A}{cs}
    &\quad
    B : \Matrix{R}{C}{E}{rs_B}{cs}
  }
\]
When comparing matrices for equality, we reassociate horizontal and
vertical pastings, so that $\hjux{\vjux{A}{C}}{\vjux{B}{D}}$ and
$\vjux{\hjux{A}{B}}{\hjux{C}{D}}$ indeed are considered equal.

Two matrices $A$ and $B$ can be added if all entry types $E(x, y)$ are
numeric (for example integers, or floating point numbers), and if $A$
and $B$ have the same matrix type:
%
\[
  \infer{A + B : \Matrix{R}{C}{E}{rs}{cs}}
  {
    x : R, y : C \vdash \isadd{E(x, y)}
    &\quad
    A : \Matrix{R}{C}{E}{rs}{cs}
    &\quad
    B : \Matrix{R}{C}{E}{rs}{cs}
  }
\]
%
Matrix multiplication is trickier, because it does not demand that $A$
and $B$ have the same type --- rather, it demands that $A$ and $B$
have \remph{compatible} types:
%
\[
  \infer{A * B : \Matrix{R}{C}{E''}{rs}{cs}}
  {
    \ismult{E}{E'}{E''}
    &\quad
    A : \Matrix{R}{C}{E}{rs}{ms}
    &\quad
    B : \Matrix{R}{C}{E'}{ms}{cs}
  }
\]
The entry types $E$, $E'$, $E''$ are multipliable if for all $x$, $y$
and $z$, we have that $E(x, y)$ and $E'(y, z)$ supports a
multiplication operation with codomain $E''(x, z)$.
%
This is certainly the case if all entry types involved are simply
integers or floating point numbers, but this constraint can also
ensure that the physical units involved line up.


% typechecking

\section{Implementation}

In contrast to most other typecheckers, LabMate works using a
\remph{transducer} model of interaction: it inputs MATLAB code with
formal comments, and outputs a new version of its input, responding to
the comments, as if it were a development collaborator.  It thus needs
to make sure that it retains as much of the input formatting as
possible.  Making sense of MATLAB code presented a significant reverse
engineering challenge, as the MATLAB syntax is largely specified
informally and by example.

LabMate elaborates MATLAB expressions and commands into terms of its own internal core type theory.
%
Because we want to ergonomically handle physical dimensions, matrices
and their types, this type theory has a richer equational theory than
other state-of-the-art type theories, which we achieve by a refined
normalisation algorithm for free Abelian groups, and free monoids.
%
The actual typechecking is implemented as a stack based virtual machine which uses unification and a limited form of backtracking to solve typing constraints.
%
After the virtual machine has solved as many problems as it can, we analyse its final state to reconstruct the output source code, perhaps with inserted warnings and error messages, or additional responses to queries.

LabMate is under constant development; the latest version can be found at \url{https://github.com/msp-strath/LabMate/tree/devel}.

\section{Supporting dimensional consistency}
\label{sec:example-revisited}

% matrix multiplication with units of measure

Coming back to the example from \sref{sec:example} again, we can give both \texttt{A} and \texttt{B} more precise types, also taking their physical dimensions into account:
\begin{verbatim}
%> A :: [ i <- 9,  j <- 5 ] (if j == 0 then Q T else Q 1)
%> B :: [ Q TODO; Q TODO; Q TODO; Q TODO; Q TODO; Q TODO ]
\end{verbatim}
This says that the entries in the first column of \texttt{A} are quantities of dimension time $\mathsf{T}$, while all other entries are dimensionless quantities. Meanwhile the entries of \texttt{B} are quantities of dimension \todo{fill in} respectively. LabMate reports that the type of \texttt{C} should be
\begin{verbatim}
%< C :: [ 5 x 1 ] (Q (ML^2T^(-3)I^(-1)))
\end{verbatim}
that is a $5 \times 1$ matrix whose entries are all quantities of dimension $\mathsf{ML}^2\mathsf{T}^{-3}\mathsf{I}^{-1}$. Another possible way to use LabMate is to instead declare that this is the expected type for \texttt{C}, and to leave the type of one of the entries in \texttt{B} as an unknown:
\begin{verbatim}
%> B :: [ Q TODO; Q TODO; ?aTy; Q TODO; Q TODO; Q TODO ]
\end{verbatim}
We can then ask LabMate to solve the \remph{meta variable} \texttt{?aTy}, to which LabMate responds that we must have \todo{\texttt{?aTy} = fill in}. This way the types of LabMate can be used to validate and experiment with the dimensional consistency of the quantities involved.

%GravCalc example again: $t_i$ time ($\mathsf{T}$; in seconds); $v_i$ voltage ($\mathsf{ML}^2\mathsf{T}^{-3}\mathsf{I}^{-1}$; in volt)


\section{Conclusions and future work}

We have demonstrated how LabMate can help write MATLAB programs that are correct both in the sense that they avoid runtime errors, as well as dimensional inconsistency for physical dimensions.
%
Getting an error for types not matching can sometimes feel like a stick, but there are also plenty of opportunities for carrots, for example where the specification encoded in the type of the program admits a single unique solution, which could be generated automatically by LabMate.
%
Similarly, LabMate already has support for generating MATLAB code for serialising and deserialising complex data formats to and from files, based on a more high-level description of the data format (for example also taking units of measure into account)~\cite{mgen}.

So far, our focus has been on matrices, as this is what makes MATLAB
unique as a programming language.
%
In the future, we would like to also extend our coverage to
conditionals and loops, which might necessitate some approximation of
what is known about program fragments at runtime.

\bibliographystyle{ws-procs9x6}
\bibliography{labmate}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
